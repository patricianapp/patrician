{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to our documentation! ( Developers : For info on contributing, including a glossary of the tools and frameworks we use, check out our developer guide.) Below is our user FAQ. If your question is not answered here, you can leave a post in our forum and we'll help you out. Basics What is Patrician? Patrician is a music profile app that lets you manage a collection of all the albums, EPs, and singles that you own, physical and/or digital. You can customize and share these profiles with anyone, and they will also have the ability to recommend albums to you. These are added to your queue, which you can then add to your collection. Each Patrician profile has powerful search options that allow you to browse your collection in a multitude of ways. You can filter and sort by release date, play count, ratings, custom tags and fields, and even compare your collection with others on the site. Overwhelmed by all the music you want to add? No worries! Patrician can import your music in a number of ways, including connecting your Spotify/Last.fm/RYM accounts, importing metadata from your local files, uploading lists in CSV/JSON/text format, and more. We offer a public GraphQL API so you can expand upon this functionality using your own apps and scripts. Upon importing, you also have the option to automatically add metadata using MusicBrainz so that your collection info is 100% accurate. What makes Patrician different from Rate Your Music/Sonemic? RYM is a fantastic way to catalog your collection and review all of the albums you listen to. Soon, Patrician will offer full compatibility with RYM so that you can keep your collection in one place and have changes reflected on both sites. RYM and Patrician are similar, in that both sites allow users to catalog their collections, write reviews, create lists, and add custom tags. However, the sites have slightly different goals in mind. RYM is focused on music discovery first and foremost, and places albums/EPs/singles at the center of attention. With Patrician, the focus is always on **user profiles**. Album pages are always viewed inside a user's profile, alongside their review, play history, favorite tracks, and other user-specific info, never as a separate page on its own. This enables us to focus on our primary goal: crafting the best profile customization experience in the music world. As a result, Patrician does not contain any aggregation features like RYM's charts. It is not intended to replace RateYourMusic, but serves a different purpose, placing all focus on the _individual_ instead of the _aggregate_. Collection Adding to Your Collection Spotify With Spotify integration, you can automatically or selectively import from your Saved Albums. You can also enable Spotify Sync, which ensures that any albums added to your Collection are also saved in your Spotify library. In addition, you can manually add items from your playlists and recent listens using the Import page. To authenticate, go to **Account** > **Login with Spotify**, and once you've logged in you will see these settings: - **Import Now**: Import all Saved Albums from Spotify into your Collection. You can then choose which albums to import, or enable Sync which will automatically import everything. - **Auto Sync**: Enables two-way synchronization between Spotify and Patrician. This will occur periodically, so your libraries are always up-to-date. - **Recommendations**: Recommend recently listened albums to add to your library. These will show up on your home page. Last.fm With Last.fm integration, you can have albums added to your Collection based on your listening history. The **Scrobble Threshold** determines how many plays an album needs in order to be added. For example, if the threshold is set to 50 (the default), it would automatically be added to your Collection once you've scrobbled (played any song from) the album 50 times. Go to **Account** > **Login with Last.fm** and type your username. No password is required. Then, you can select import options including your Scrobble Threshold. Local Files (Picard integration coming soon) (Dropbox/Google Drive integration coming soon) To add to your Collection from local files, it is recommended to use the command line as described below. These commands create a JSON-formatted list which you can then upload to Patrician. In the future, we will have GUI options available. Alternatively, you can use a ### Foobar2000 https://hydrogenaud.io/index.php?topic=61784.0 ### MP3Tag https://community.mp3tag.de/t/export-album-list/19168/2 ### Musicbee https://getmusicbee.com/forum/index.php?topic=15966.0 https://getmusicbee.com/forum/index.php?topic=24004.0 ### Clementine 1. Fetch missing tags from MusicBrainz 2. Upload .config/Clementine/clementine.db **Note**: Your library MUST be organized in the following way: Artist Folder > Album Folder > Audio File, otherwise Patrician will not detect the files. ### Windows ### MacOS/Linux 1. Open the Terminal app. 2. Navigate to your music library using the \"cd\" command (e.g. `cd Music`) 3. Type `ls` to make sure you are in the correct folder. You should see a list of artist folders. 4. Type this command to generate a list of artists and albums: `tree -dJ -o tree.json` 5. On Patrician, go to **Account** > **Import from Local Files**, and select the \"tree.json\" file from your music folder. 6. Select which albums you'd like to import, or click \"Select All\". ListenBrainz With Last.fm integration, you can have albums added to your Collection based on your listening history. The **Scrobble Threshold** determines how many plays an album needs in order to be added. For example, if the threshold is set to 50 (the default), it would automatically be added to your Collection once you've scrobbled (played any song from) the album 50 times. Go to **Account** > **Login with Last.fm** and type your username. No password is required. Then, you can select import options including your Scrobble Threshold. Libre.fm With Last.fm integration, you can have albums added to your Collection based on your listening history. The **Scrobble Threshold** determines how many plays an album needs in order to be added. For example, if the threshold is set to 50 (the default), it would automatically be added to your Collection once you've scrobbled (played any song from) the album 50 times. Go to **Account** > **Login with Last.fm** and type your username. No password is required. Then, you can select import options including your Scrobble Threshold. iTunes/Apple Music You can import albums from iTunes/Apple Music into your Collection by opening iTunes and going to the File menu > Library > Export Library. Then upload the XML file that was saved. Rate Your Music/Sonemic Sonemic doesn't yet currently have a public API, so Patrician can't automatically sync with this service. However, you can import albums manually from your profile: 1. Navigate to your RateYourMusic profile page. 2. At the bottom, click \"Export your data\" or \"Export with reviews\" and save this to a file. 3. On Patrician, go to **Account** > **Import from RYM/Sonemic**. 4. Select the CSV file that you saved in step 2. 5. Select which albums you'd like to import, or click \"Select All\". Discogs Coming soon. YouTube Music Coming soon. Type a list of albums Coming soon. Browsing Collections What custom search options are there? Managing Your Collections How do I delete an album? How do I delete many albums at once (a.k.a. mass delete)? Some of my albums have incorrect metadata. Can I edit this? Profile How do I customize my public profile? How do I make album collages (like the ones people share from Tapmusic, etc)? You can generate album collages from your listening history or by searching/filtering your Collections. Can I make a profile for an organization or group of people? This is not supported at the moment, but will be in the future. Social Can I follow my friends on Patrician? Yes, you can follow your friends by visiting their profiles or searching for their username. Once you've followed them, you'll see updates in your feed when they update their Collections, have new top artists, or receive recommendations. How can people recommend albums to me? How do I see a list of recommendations I've received? Someone recommended an album to me outside of Patrician. Can I manually add it to my Queue? Yes. Your queue is a fully manageable list of albums that you intend to listen to. You can add albums to it by navigating to your queue and clicking \"Add\". Do people need a Patrician account to recommend albums to me? Lists How do I create a List? Can I change the visibility of my List? How do I share my List with others?","title":"Home"},{"location":"#basics","text":"What is Patrician? Patrician is a music profile app that lets you manage a collection of all the albums, EPs, and singles that you own, physical and/or digital. You can customize and share these profiles with anyone, and they will also have the ability to recommend albums to you. These are added to your queue, which you can then add to your collection. Each Patrician profile has powerful search options that allow you to browse your collection in a multitude of ways. You can filter and sort by release date, play count, ratings, custom tags and fields, and even compare your collection with others on the site. Overwhelmed by all the music you want to add? No worries! Patrician can import your music in a number of ways, including connecting your Spotify/Last.fm/RYM accounts, importing metadata from your local files, uploading lists in CSV/JSON/text format, and more. We offer a public GraphQL API so you can expand upon this functionality using your own apps and scripts. Upon importing, you also have the option to automatically add metadata using MusicBrainz so that your collection info is 100% accurate. What makes Patrician different from Rate Your Music/Sonemic? RYM is a fantastic way to catalog your collection and review all of the albums you listen to. Soon, Patrician will offer full compatibility with RYM so that you can keep your collection in one place and have changes reflected on both sites. RYM and Patrician are similar, in that both sites allow users to catalog their collections, write reviews, create lists, and add custom tags. However, the sites have slightly different goals in mind. RYM is focused on music discovery first and foremost, and places albums/EPs/singles at the center of attention. With Patrician, the focus is always on **user profiles**. Album pages are always viewed inside a user's profile, alongside their review, play history, favorite tracks, and other user-specific info, never as a separate page on its own. This enables us to focus on our primary goal: crafting the best profile customization experience in the music world. As a result, Patrician does not contain any aggregation features like RYM's charts. It is not intended to replace RateYourMusic, but serves a different purpose, placing all focus on the _individual_ instead of the _aggregate_.","title":"Basics"},{"location":"#collection","text":"","title":"Collection"},{"location":"#adding-to-your-collection","text":"Spotify With Spotify integration, you can automatically or selectively import from your Saved Albums. You can also enable Spotify Sync, which ensures that any albums added to your Collection are also saved in your Spotify library. In addition, you can manually add items from your playlists and recent listens using the Import page. To authenticate, go to **Account** > **Login with Spotify**, and once you've logged in you will see these settings: - **Import Now**: Import all Saved Albums from Spotify into your Collection. You can then choose which albums to import, or enable Sync which will automatically import everything. - **Auto Sync**: Enables two-way synchronization between Spotify and Patrician. This will occur periodically, so your libraries are always up-to-date. - **Recommendations**: Recommend recently listened albums to add to your library. These will show up on your home page. Last.fm With Last.fm integration, you can have albums added to your Collection based on your listening history. The **Scrobble Threshold** determines how many plays an album needs in order to be added. For example, if the threshold is set to 50 (the default), it would automatically be added to your Collection once you've scrobbled (played any song from) the album 50 times. Go to **Account** > **Login with Last.fm** and type your username. No password is required. Then, you can select import options including your Scrobble Threshold. Local Files (Picard integration coming soon) (Dropbox/Google Drive integration coming soon) To add to your Collection from local files, it is recommended to use the command line as described below. These commands create a JSON-formatted list which you can then upload to Patrician. In the future, we will have GUI options available. Alternatively, you can use a ### Foobar2000 https://hydrogenaud.io/index.php?topic=61784.0 ### MP3Tag https://community.mp3tag.de/t/export-album-list/19168/2 ### Musicbee https://getmusicbee.com/forum/index.php?topic=15966.0 https://getmusicbee.com/forum/index.php?topic=24004.0 ### Clementine 1. Fetch missing tags from MusicBrainz 2. Upload .config/Clementine/clementine.db **Note**: Your library MUST be organized in the following way: Artist Folder > Album Folder > Audio File, otherwise Patrician will not detect the files. ### Windows ### MacOS/Linux 1. Open the Terminal app. 2. Navigate to your music library using the \"cd\" command (e.g. `cd Music`) 3. Type `ls` to make sure you are in the correct folder. You should see a list of artist folders. 4. Type this command to generate a list of artists and albums: `tree -dJ -o tree.json` 5. On Patrician, go to **Account** > **Import from Local Files**, and select the \"tree.json\" file from your music folder. 6. Select which albums you'd like to import, or click \"Select All\". ListenBrainz With Last.fm integration, you can have albums added to your Collection based on your listening history. The **Scrobble Threshold** determines how many plays an album needs in order to be added. For example, if the threshold is set to 50 (the default), it would automatically be added to your Collection once you've scrobbled (played any song from) the album 50 times. Go to **Account** > **Login with Last.fm** and type your username. No password is required. Then, you can select import options including your Scrobble Threshold. Libre.fm With Last.fm integration, you can have albums added to your Collection based on your listening history. The **Scrobble Threshold** determines how many plays an album needs in order to be added. For example, if the threshold is set to 50 (the default), it would automatically be added to your Collection once you've scrobbled (played any song from) the album 50 times. Go to **Account** > **Login with Last.fm** and type your username. No password is required. Then, you can select import options including your Scrobble Threshold. iTunes/Apple Music You can import albums from iTunes/Apple Music into your Collection by opening iTunes and going to the File menu > Library > Export Library. Then upload the XML file that was saved. Rate Your Music/Sonemic Sonemic doesn't yet currently have a public API, so Patrician can't automatically sync with this service. However, you can import albums manually from your profile: 1. Navigate to your RateYourMusic profile page. 2. At the bottom, click \"Export your data\" or \"Export with reviews\" and save this to a file. 3. On Patrician, go to **Account** > **Import from RYM/Sonemic**. 4. Select the CSV file that you saved in step 2. 5. Select which albums you'd like to import, or click \"Select All\". Discogs Coming soon. YouTube Music Coming soon. Type a list of albums Coming soon.","title":"Adding to Your Collection"},{"location":"#browsing-collections","text":"What custom search options are there?","title":"Browsing Collections"},{"location":"#managing-your-collections","text":"How do I delete an album? How do I delete many albums at once (a.k.a. mass delete)? Some of my albums have incorrect metadata. Can I edit this?","title":"Managing Your Collections"},{"location":"#profile","text":"How do I customize my public profile? How do I make album collages (like the ones people share from Tapmusic, etc)? You can generate album collages from your listening history or by searching/filtering your Collections. Can I make a profile for an organization or group of people? This is not supported at the moment, but will be in the future.","title":"Profile"},{"location":"#social","text":"Can I follow my friends on Patrician? Yes, you can follow your friends by visiting their profiles or searching for their username. Once you've followed them, you'll see updates in your feed when they update their Collections, have new top artists, or receive recommendations. How can people recommend albums to me? How do I see a list of recommendations I've received? Someone recommended an album to me outside of Patrician. Can I manually add it to my Queue? Yes. Your queue is a fully manageable list of albums that you intend to listen to. You can add albums to it by navigating to your queue and clicking \"Add\". Do people need a Patrician account to recommend albums to me?","title":"Social"},{"location":"#lists","text":"How do I create a List? Can I change the visibility of my List? How do I share my List with others?","title":"Lists"},{"location":"intro/","text":"","title":"Intro"},{"location":"dev-guide/dev-setup/","text":"","title":"Local Setup"},{"location":"dev-guide/glossary/","text":"Amazon Aurora Official site What is it? A proprietary cloud database service that has compatibility with Postgres and MySQL clients. What do we use it for? The Patrician database that stores user and item info. Alternatives: Amazon DocumentDB (if we wanted to use a MongoDB client instead), or a typical managed Postgres service like Digital Ocean Databases. Aurora claims to be the fastest of any of these options. Amazon ECS Official site What is it? An AWS service for hosting Docker containers. What do we use it for? It's likely that we'll use this to host our MusicBrainz instance. Alternatives: I don't know of any managed Docker services like ECS that exist (most of them tend to be Kubernetes services, which we don't need). The alternative would probably be managing Docker containers on our own VPS (EC2, Digital Ocean, Linode, etc). Apollo Client Official site What is it? A JavaScript library for making GraphQL requests from the browser or in Node.js. What do we use it for? This is the framework we use for fetching data in the Patrician UI. Alternatives: Gqless is an option that touts itself as \"query-less\", meaning it auto generates the query you need to run based on the data being accessed inside a component. It's still a young project, but worth evaluating. Relay is a library created by Facebook, specifically designed for React and featuring strong conventions regarding pagination and other things. Since we are designing the API to be Relay-compatible, this is an option we can look at. Urql is another option that I've seen mentioned, but I haven't found any benefit over Apollo Client. Apollo Client is currently the most popular and well-supported option, and its newest update that makes use of Hooks offers a fantastic dev experience, as well as its integration with the Apollo ecosystem which is currently dominating the GraphQL landscape. Apollo Server Official site What is it? A production-ready Node.js library for creating GraphQL servers. What do we use it for? Warthog, which the Patrician API is built on, uses Apollo Server under the hood. If we decide to not use Warthog at some point, it's likely that we would still want to use Apollo Server. Alternatives: Express-graphql is a smaller library that's focused more on simplicity than features. For production-level Node.js apps, there doesn't seem to be any competitor to Apollo Server. Similar libraries such as graphql-yoga use Apollo under the hood. AWS Lambda Official site What is it? Cloud runtime for executing functions on-demand, either via an API endpoint or through other AWS services. What do we use it for? Nothing yet, but this is most likely where we will put the \"importer\" functions that import large libraries from Last.fm, Spotify, etc. because we don't want that work clogging up the main thread that our server runs on. Alternatives: Google Firebase Cloud Functions: This would be a nice solution, but right now it's heavily tied to Node.js, and we might eventually want to write these functions in other languages. (Lambda, by comparison, supports Java, Go, PowerShell, Node. js, C#, Python, and Ruby.) Docker Official site What is it? A virtualization tool that allows applications to run anywhere that has Docker installed. What do we use it for? I'm not 100% convinced that we need it, since Heroku can host Node.js applications without it, but this would enable our API to be very portable, and it would ease the dev experience for our team and for others who want to self-host Patrician instances. Alternatives: As of 2020, Docker is by and large an industry standard. ESLint Official site What is it? A tool for automated \"linting\", which finds errors in our code, and in some cases attempts to auto-fix them. What do we use it for? Code checking on every commit, thanks to Husky and Lint-Staged. Alternatives: No real alternatives. Ghost Official site What is it? A blogging platform/CMS, written in Node.js, that features an admin UI for creating accounts and writing posts. What do we use it for? Might use this for our public-facing blog where we demonstrate new app features. There's a handy Heroku installer that seems to work pretty well. Alternatives: Haven't done a huge amount of research on this yet. Wordpress would be an obvious alternative, but I'd like to use something more modern, and I really like the look and feel of Ghost in comparison. GitHub Official site What is it? A hosting service for code that uses Git version control to keep track of history and collaboration between users. What do we use it for? Hosting all of our code, and keeping track of our tasks in the form of Issues. Alternatives: GitLab would also be an awesome choice, but GitHub is what most developers are used to (which makes it easier to find contributors), and it's also what my company uses, so it makes the most sense for this project. GraphQL Official site What is it? A protocol for web server communication that allows clients to specify data fields. What do we use it for? The Patrician API uses GraphQL as its communication protocol. Alternatives: REST is the main alternative, and the main reason for going with GraphQL is that, because this will be a public API, we want to serve many use cases and offer the best tooling available. GraphQL is a standardized query language, which means that developers who are used to other GraphQL APIs such as GitHub and Shopify will feel right at home. Hasura Official site What is it? An open-source application that serves an autogenerated GraphQL endpoint for a Postgres database, complete with CRUD operations for all tables and integrations for server-side business logic. What do we use it for? Nothing at this point, however I was considering using this as our API instead of the Warthog application we're building. The main difference is that Hasura relies on the database layer for a lot of business logic, which would likely be faster due to Postgres's optimization. I decided against this, because it seemed like it would be a lot more work compared to our current option, and would likely allow for less customization of our business logic. Alternatives: The closest comparison to this would be Postgraphile, which I turned down for similar reasons. The alternative we've chosen for this project is our own TypeScript API that uses the Warthog framework (a wrapper for TypeORM/TypeGraphQL that reduces boilerplate and auto-generates some API functionality). Heroku Official site What is it? A cloud platform for easily hosting applications in a number of languages/runtimes. What do we use it for? Hosting the Patrician API, and possibly our blog as well. Alternatives: There are several. The most similar to Heroku would probably be AWS Elastic Beanstalk, which also has a simple setup process. We could also self-manage a VPS using a service like Digital Ocean, or self-manage a Kubernetes cluster using EKS or Google Cloud. These are all options we can revisit at some point, but right now Heroku is the go-to for its simplicity, plugin architecture, and auto-scaling ability. Reasons to switch to something else could be for pricing, better scalability, higher speeds, integration with other services, logging, better CI/CD, and more. Husky Official site What is it? An npm package for running npm commands on git hooks (pre-commit, pre-push, etc) What do we use it for? (Along with lint-staged) Linting, formatting, testing, and building documentation on pre-commit. Alternatives: pre-commit (not as popular, not as many features) Jest Official site What is it? A Node.js library for creating and running automated tests. What do we use it for? Unit, integration, and e2e tests that ensure our applications are always functioning correctly and that we don't break things when making changes. Alternatives: Jest is by far the most popular test framework, followed by Jasmine. Last.fm Official site What is it? A music profile website that connects to various music players and logs listening history. What do we use it for? Plays (scrobbles) from Last.fm accounts can be imported into Patrician. Right now we just use the data to collect all of the albums, but eventually we will want to store the actual scrobbles in our database to allow for more powerful functionality. Alternatives: This is currently the primary website that people use for storing their listening history. Libre.fm is also a well-known one, and ListenBrainz is much newer but hopefully will become popular over time. Lint-Staged Official site What is it? A Node.js library that allows you to run commands (e.g. eslint) on files that are staged for commit. What do we use it for? Linting/formatting/testing staged files, running mkdocs build when docs change. Alternatives: None that I know of. ListenBrainz Official site What is it? A service that logs listening history, very similar to Last.fm. Created by MusicBrainz. What do we use it for? We will eventually allow users to import listens from this service, and may even use our own hosted ListenBrainz server as a way of storing listening history on our end. Alternatives: As for creating our own listening history logger, some other options worth looking into would be GNU FM and Maljola . Lucene Official site What is it? A Java library providing powerful indexing and search features, as well as spellchecking, hit highlighting and advanced analysis/tokenization capabilities. What do we use it for? We don't currently use Lucene itself for anything, however our query syntax is modelled after the Lucene query syntax . MusicBrainz uses Lucene for its advanced search , so I wanted a syntax that would be familiar for MusicBrainz users. Many search engines, including Gmail's , use a very similar language. It's unlikely that we'll need to use Lucene itself as a search engine, since we're mostly just querying user's collections (a much smaller amount of results than searching a general database of albums) Material Design Official site What is it? A design system created by Google that is known for its flat design. It's used in most Google products, including Android, and is especially popular on the web. Many CSS and web component libraries exist that facilitate the use of Material Design for developers and designers. What do we use it for? Since the Patrician site uses Material-UI as its primary component library, it follows Material Design by default. It's currently unknown how closely we'll stick to Material Design principles when the site launches, however there's definitely some ideas I want to keep, such as the animation styles. Alternatives: I'm sure there are many other UI design philosophies out there, but I haven't looked into them yet. Material-UI Official site What is it? A React component library that follows Material Design principles by default (though is not locked to them), as well as accessibility features, responsiveness, grid layout, and extensive theming capabilities. What do we use it for? Our UI site is currently being built using Material-UI. Alternatives: There are several general-purpose React component libraries similar to this one, including Ant-Design and React Bootstrap. Material-UI is the most extensively documented, well-known, and customizable component library out there, and seems like a perfect fit for Patrician. MkDocs Official site What is it? MkDocs is a static-site documentation generator that uses Markdown files. What do we use it for? The documentation you're looking at right now (unless you're viewing it on GitHub) has been generated using MKDocs with the MKDocs Material Theme. The Markdown files are stored in the /docs folder of the Patrician UI repo, and we have a pre-commit hook runs mkdocs build whenever these files change, placing the output in /public where they are served as part of the main Patrician site. Alternatives: Sphinx, GitBook and MDBook are all options I looked at. I chose MkDocs because it's modern and I like its themes the best. Doesn't this site look pretty? MusicBrainz Official site What is it? An open music encyclopedia that collects music metadata and makes it available to the public. What do we use it for? MusicBrainz is the service we use for collecting item metadata. We plan on signing up for their non-profit tier , which would enable us to host our own MusicBrainz server which would be automatically kept up-to-date from their API. Alternatives: Wikipedia has a list of online music databases . Of all the open-source options that suit our specific metadata needs, none are as feature-rich and precise as MusicBrainz. Next.js Official site What is it? A frontend framework built around React for creating hybrid production apps that can be server-rendered and statically optimized. What do we use it for? Next.js is the framework we're using for our UI. Alternatives: I like Next.js for its flexibility, first-class TypeScript support, and tight integration with Vercel's hosting service. There are some other React frameworks that are built around Next.js, such as Redwood and Blitz, but the additional features they add are unnecessary for our use case. Notion Official site What is it? A collaborative note-taking platform that integrates kanban boards, tasks, wikis, and databases. What do we use it for? Public expense reports. I like using Notion for this due to the flexible way it manages spreadsheets/tables. I've considered using it for numerous other things, all of which I found better replacements for, including project management (ZenHub), blogging (Ghost), and documentation (MkDocs). Alternatives: For expense reports, probably Google Sheets, which is less flexible and less flattering than Notion. For everything else mentioned, I'm currently using the alternatives mentioned above. Playwright Official site What is it? A Node library to automate Chromium, Firefox and WebKit with a single API. Playwright is built to enable cross-browser web automation that is ever-green, capable, reliable and fast. What do we use it for? This will most likely be our browser automation framework for end-to-end tests. Alternatives: Cypress, Puppeteer, and Selenium would be the main competitors. Playwright is the only one that automates all three major browser engines while running completely inside Node. It's created by Microsoft which gives me faith in its quality. It is, however, very new, having just gotten to its 1.0 release as of May 2020. PostgreSQL Official site What is it? An advanced open-source relational database. What do we use it for? For local development we use Postgres inside a Docker container, and in production we use a Postgres-compatible Aurora instance. In both cases, this serves as the backend for our API, managing users, items, reviews, and everything else we need to store. Alternatives: The main alternatives would be MongoDB and MySQL, which I don't see offering any advantage over Postgres. Prettier Official site What is it? An opinionated code formatter What do we use it for? Enforcing code formatting standards across all repos, including tabs over spaces . Alternatives: Prettier seems to be the current standard. React Official site What is it? A web framework for building user interfaces using JavaScript and JSX. What do we use it for? The Patrician site is built using React with Next.js. Alternatives: Angular and Vue are the other major JavaScript frameworks, both of which I've also had some experience using. All three of them use a component architecture and have the same basic capabilities, and we could reasonably use any framework for Patrician. We're currently choosing React because it's popular in the dev community, has lots of open-source components available and widespread support, and has a fairly intuitive coding style with JSX. Redis Official site What is it? An open source, in-memory data structure store, used as a database, cache and message broker. Uses a key-value storage method. What do we use it for? We may use this for caching album art to speed up collage generation. Current collage generators take a while because make tons of REST calls, and I think there's a great opportunity for speed improvement here. Alternatives: Memcached? Release-Drafter Official site What is it? A GitHub Actions script that drafts release descriptions based on the PRs that have been merged since last release. What do we use it for? Creating releases for both our UI and API. Alternatives: Zeit/release was initally the option I wanted to use, but that generates release descriptions based on commits, not PRs, meaning we would have to do squash merges. This would be fine if not for the fact that after a squash merge, you can no longer commit to that feature branch, so this could make for a frustrating dev workflow. I'm not opposed to revisiting this idea in the future. Storybook Official site What is it? A tool for prototyping UI components in isolation. Compatible with React and other major web frameworks. What do we use it for? We will probably want to use this to test our UI components as we're working on them. Alternatives: ??? TypeGraphQL Official site What is it? A Node.js library for generating a GraphQL schema using TypeScript decorators, which can then be fed into a GraphQL server such as Apollo Server. What do we use it for? Creating the GraphqQL schema for Patrician API (part of Warthog). Alternatives: graphql-js, or just using Apollo server on its own and defining the schema using their own syntax or in .graphql files. Using TypeGraphQL, especially as part of Warthog, reduces our boilerplate by having our code, schema, and data models all in one place. TypeORM Official site What is it? An ORM (object-relational model) database client that uses TypeScript decorators to describe data models. What do we use it for? Creating the data models and migrations for Patrician API (part of Warthog). Alternatives: Sequelize used to be the go-to, but TypeORM has since grown in popularity. MikroORM is a similar project that is also gaining traction due to the slow development of TypeORM. Prisma2 looks very promising with its superb TypeScript support and autogenerated classes based on the data model, but it would require defining the data model in its own syntax as opposed to writing out the TypeScript classes. It's something worth revisiting once a stable version is released, but until TypeORM gives us any major issues we will probably stick with it. TypeScript Official site What is it? A programming language that transpiles to JavaScript, offering type-checking and deep code editor integration, especially with VSCode. What do we use it for? TypeScript is what the majority (currently all) of our code is written in, including the UI and API. Alternatives: No real alternatives, although due to our microserviec architecture and desire for maximum performance, I could see some of our code moving away from JavaScript altogether, but it'll be a while before that happens. Vercel Official site What is it? A full-stack web hosting platform made by the creators of Next.js with built-in CI/CD (automatically deploys when code is merged in GitHub). What do we use it for? Serving the Patrician UI. Alternatives: Netlify would be an option if we abandoned SSR (making our site fully client-rendered/static). The other options would be AWS (many options to choose from) and Heroku. Vercel has been working great so far, is built by the creators of Next.js, and offers just about everything we need out of the box. Warthog Official site What is it? A GraphQL API framework for NodeJS that allows you to define your data model and API schema in one place and autogenerates CRUD operations with sorting, filtering, and pagination out of the box. Built on top of TypeORM and TypeGraphQL. What do we use it for? This is the framework we're currently using for the Patrician API. Alternatives: There are many options for a GraphQL framework that we could go with. I've written prototypes for the basic functionality in Nest.js, Hasura, and a TypeORM/TypeGraphQL app from scratch before I found this framework which offers a lot out of the box. Warthog is a small project and we're still evaluating if it will fit our needs in the long run, but we've had success with it so far. If at some point it fails to do so, we may look at Hasura again (or perhaps Postgraphile) or re-build our API from scratch using either TypeORM/TypeGraphQL or experiment with other frameworks (Prisma2, graphql-yoga, etc). ZenHub Official site What is it? A project management tool with deep GitHub integration. What do we use it for? Organizing our GitHub issues into a project board with Epics and a roadmap. Alternatives: Codetree, Jira, GitKraken Glo, Notion, ClickUp, Trello, Taiga","title":"Dev Glossary"},{"location":"dev-guide/glossary/#amazon-aurora","text":"Official site What is it? A proprietary cloud database service that has compatibility with Postgres and MySQL clients. What do we use it for? The Patrician database that stores user and item info. Alternatives: Amazon DocumentDB (if we wanted to use a MongoDB client instead), or a typical managed Postgres service like Digital Ocean Databases. Aurora claims to be the fastest of any of these options.","title":"Amazon Aurora"},{"location":"dev-guide/glossary/#amazon-ecs","text":"Official site What is it? An AWS service for hosting Docker containers. What do we use it for? It's likely that we'll use this to host our MusicBrainz instance. Alternatives: I don't know of any managed Docker services like ECS that exist (most of them tend to be Kubernetes services, which we don't need). The alternative would probably be managing Docker containers on our own VPS (EC2, Digital Ocean, Linode, etc).","title":"Amazon ECS"},{"location":"dev-guide/glossary/#apollo-client","text":"Official site What is it? A JavaScript library for making GraphQL requests from the browser or in Node.js. What do we use it for? This is the framework we use for fetching data in the Patrician UI. Alternatives: Gqless is an option that touts itself as \"query-less\", meaning it auto generates the query you need to run based on the data being accessed inside a component. It's still a young project, but worth evaluating. Relay is a library created by Facebook, specifically designed for React and featuring strong conventions regarding pagination and other things. Since we are designing the API to be Relay-compatible, this is an option we can look at. Urql is another option that I've seen mentioned, but I haven't found any benefit over Apollo Client. Apollo Client is currently the most popular and well-supported option, and its newest update that makes use of Hooks offers a fantastic dev experience, as well as its integration with the Apollo ecosystem which is currently dominating the GraphQL landscape.","title":"Apollo Client"},{"location":"dev-guide/glossary/#apollo-server","text":"Official site What is it? A production-ready Node.js library for creating GraphQL servers. What do we use it for? Warthog, which the Patrician API is built on, uses Apollo Server under the hood. If we decide to not use Warthog at some point, it's likely that we would still want to use Apollo Server. Alternatives: Express-graphql is a smaller library that's focused more on simplicity than features. For production-level Node.js apps, there doesn't seem to be any competitor to Apollo Server. Similar libraries such as graphql-yoga use Apollo under the hood.","title":"Apollo Server"},{"location":"dev-guide/glossary/#aws-lambda","text":"Official site What is it? Cloud runtime for executing functions on-demand, either via an API endpoint or through other AWS services. What do we use it for? Nothing yet, but this is most likely where we will put the \"importer\" functions that import large libraries from Last.fm, Spotify, etc. because we don't want that work clogging up the main thread that our server runs on. Alternatives: Google Firebase Cloud Functions: This would be a nice solution, but right now it's heavily tied to Node.js, and we might eventually want to write these functions in other languages. (Lambda, by comparison, supports Java, Go, PowerShell, Node. js, C#, Python, and Ruby.)","title":"AWS Lambda"},{"location":"dev-guide/glossary/#docker","text":"Official site What is it? A virtualization tool that allows applications to run anywhere that has Docker installed. What do we use it for? I'm not 100% convinced that we need it, since Heroku can host Node.js applications without it, but this would enable our API to be very portable, and it would ease the dev experience for our team and for others who want to self-host Patrician instances. Alternatives: As of 2020, Docker is by and large an industry standard.","title":"Docker"},{"location":"dev-guide/glossary/#eslint","text":"Official site What is it? A tool for automated \"linting\", which finds errors in our code, and in some cases attempts to auto-fix them. What do we use it for? Code checking on every commit, thanks to Husky and Lint-Staged. Alternatives: No real alternatives.","title":"ESLint"},{"location":"dev-guide/glossary/#ghost","text":"Official site What is it? A blogging platform/CMS, written in Node.js, that features an admin UI for creating accounts and writing posts. What do we use it for? Might use this for our public-facing blog where we demonstrate new app features. There's a handy Heroku installer that seems to work pretty well. Alternatives: Haven't done a huge amount of research on this yet. Wordpress would be an obvious alternative, but I'd like to use something more modern, and I really like the look and feel of Ghost in comparison.","title":"Ghost"},{"location":"dev-guide/glossary/#github","text":"Official site What is it? A hosting service for code that uses Git version control to keep track of history and collaboration between users. What do we use it for? Hosting all of our code, and keeping track of our tasks in the form of Issues. Alternatives: GitLab would also be an awesome choice, but GitHub is what most developers are used to (which makes it easier to find contributors), and it's also what my company uses, so it makes the most sense for this project.","title":"GitHub"},{"location":"dev-guide/glossary/#graphql","text":"Official site What is it? A protocol for web server communication that allows clients to specify data fields. What do we use it for? The Patrician API uses GraphQL as its communication protocol. Alternatives: REST is the main alternative, and the main reason for going with GraphQL is that, because this will be a public API, we want to serve many use cases and offer the best tooling available. GraphQL is a standardized query language, which means that developers who are used to other GraphQL APIs such as GitHub and Shopify will feel right at home.","title":"GraphQL"},{"location":"dev-guide/glossary/#hasura","text":"Official site What is it? An open-source application that serves an autogenerated GraphQL endpoint for a Postgres database, complete with CRUD operations for all tables and integrations for server-side business logic. What do we use it for? Nothing at this point, however I was considering using this as our API instead of the Warthog application we're building. The main difference is that Hasura relies on the database layer for a lot of business logic, which would likely be faster due to Postgres's optimization. I decided against this, because it seemed like it would be a lot more work compared to our current option, and would likely allow for less customization of our business logic. Alternatives: The closest comparison to this would be Postgraphile, which I turned down for similar reasons. The alternative we've chosen for this project is our own TypeScript API that uses the Warthog framework (a wrapper for TypeORM/TypeGraphQL that reduces boilerplate and auto-generates some API functionality).","title":"Hasura"},{"location":"dev-guide/glossary/#heroku","text":"Official site What is it? A cloud platform for easily hosting applications in a number of languages/runtimes. What do we use it for? Hosting the Patrician API, and possibly our blog as well. Alternatives: There are several. The most similar to Heroku would probably be AWS Elastic Beanstalk, which also has a simple setup process. We could also self-manage a VPS using a service like Digital Ocean, or self-manage a Kubernetes cluster using EKS or Google Cloud. These are all options we can revisit at some point, but right now Heroku is the go-to for its simplicity, plugin architecture, and auto-scaling ability. Reasons to switch to something else could be for pricing, better scalability, higher speeds, integration with other services, logging, better CI/CD, and more.","title":"Heroku"},{"location":"dev-guide/glossary/#husky","text":"Official site What is it? An npm package for running npm commands on git hooks (pre-commit, pre-push, etc) What do we use it for? (Along with lint-staged) Linting, formatting, testing, and building documentation on pre-commit. Alternatives: pre-commit (not as popular, not as many features)","title":"Husky"},{"location":"dev-guide/glossary/#jest","text":"Official site What is it? A Node.js library for creating and running automated tests. What do we use it for? Unit, integration, and e2e tests that ensure our applications are always functioning correctly and that we don't break things when making changes. Alternatives: Jest is by far the most popular test framework, followed by Jasmine.","title":"Jest"},{"location":"dev-guide/glossary/#lastfm","text":"Official site What is it? A music profile website that connects to various music players and logs listening history. What do we use it for? Plays (scrobbles) from Last.fm accounts can be imported into Patrician. Right now we just use the data to collect all of the albums, but eventually we will want to store the actual scrobbles in our database to allow for more powerful functionality. Alternatives: This is currently the primary website that people use for storing their listening history. Libre.fm is also a well-known one, and ListenBrainz is much newer but hopefully will become popular over time.","title":"Last.fm"},{"location":"dev-guide/glossary/#lint-staged","text":"Official site What is it? A Node.js library that allows you to run commands (e.g. eslint) on files that are staged for commit. What do we use it for? Linting/formatting/testing staged files, running mkdocs build when docs change. Alternatives: None that I know of.","title":"Lint-Staged"},{"location":"dev-guide/glossary/#listenbrainz","text":"Official site What is it? A service that logs listening history, very similar to Last.fm. Created by MusicBrainz. What do we use it for? We will eventually allow users to import listens from this service, and may even use our own hosted ListenBrainz server as a way of storing listening history on our end. Alternatives: As for creating our own listening history logger, some other options worth looking into would be GNU FM and Maljola .","title":"ListenBrainz"},{"location":"dev-guide/glossary/#lucene","text":"Official site What is it? A Java library providing powerful indexing and search features, as well as spellchecking, hit highlighting and advanced analysis/tokenization capabilities. What do we use it for? We don't currently use Lucene itself for anything, however our query syntax is modelled after the Lucene query syntax . MusicBrainz uses Lucene for its advanced search , so I wanted a syntax that would be familiar for MusicBrainz users. Many search engines, including Gmail's , use a very similar language. It's unlikely that we'll need to use Lucene itself as a search engine, since we're mostly just querying user's collections (a much smaller amount of results than searching a general database of albums)","title":"Lucene"},{"location":"dev-guide/glossary/#material-design","text":"Official site What is it? A design system created by Google that is known for its flat design. It's used in most Google products, including Android, and is especially popular on the web. Many CSS and web component libraries exist that facilitate the use of Material Design for developers and designers. What do we use it for? Since the Patrician site uses Material-UI as its primary component library, it follows Material Design by default. It's currently unknown how closely we'll stick to Material Design principles when the site launches, however there's definitely some ideas I want to keep, such as the animation styles. Alternatives: I'm sure there are many other UI design philosophies out there, but I haven't looked into them yet.","title":"Material Design"},{"location":"dev-guide/glossary/#material-ui","text":"Official site What is it? A React component library that follows Material Design principles by default (though is not locked to them), as well as accessibility features, responsiveness, grid layout, and extensive theming capabilities. What do we use it for? Our UI site is currently being built using Material-UI. Alternatives: There are several general-purpose React component libraries similar to this one, including Ant-Design and React Bootstrap. Material-UI is the most extensively documented, well-known, and customizable component library out there, and seems like a perfect fit for Patrician.","title":"Material-UI"},{"location":"dev-guide/glossary/#mkdocs","text":"Official site What is it? MkDocs is a static-site documentation generator that uses Markdown files. What do we use it for? The documentation you're looking at right now (unless you're viewing it on GitHub) has been generated using MKDocs with the MKDocs Material Theme. The Markdown files are stored in the /docs folder of the Patrician UI repo, and we have a pre-commit hook runs mkdocs build whenever these files change, placing the output in /public where they are served as part of the main Patrician site. Alternatives: Sphinx, GitBook and MDBook are all options I looked at. I chose MkDocs because it's modern and I like its themes the best. Doesn't this site look pretty?","title":"MkDocs"},{"location":"dev-guide/glossary/#musicbrainz","text":"Official site What is it? An open music encyclopedia that collects music metadata and makes it available to the public. What do we use it for? MusicBrainz is the service we use for collecting item metadata. We plan on signing up for their non-profit tier , which would enable us to host our own MusicBrainz server which would be automatically kept up-to-date from their API. Alternatives: Wikipedia has a list of online music databases . Of all the open-source options that suit our specific metadata needs, none are as feature-rich and precise as MusicBrainz.","title":"MusicBrainz"},{"location":"dev-guide/glossary/#nextjs","text":"Official site What is it? A frontend framework built around React for creating hybrid production apps that can be server-rendered and statically optimized. What do we use it for? Next.js is the framework we're using for our UI. Alternatives: I like Next.js for its flexibility, first-class TypeScript support, and tight integration with Vercel's hosting service. There are some other React frameworks that are built around Next.js, such as Redwood and Blitz, but the additional features they add are unnecessary for our use case.","title":"Next.js"},{"location":"dev-guide/glossary/#notion","text":"Official site What is it? A collaborative note-taking platform that integrates kanban boards, tasks, wikis, and databases. What do we use it for? Public expense reports. I like using Notion for this due to the flexible way it manages spreadsheets/tables. I've considered using it for numerous other things, all of which I found better replacements for, including project management (ZenHub), blogging (Ghost), and documentation (MkDocs). Alternatives: For expense reports, probably Google Sheets, which is less flexible and less flattering than Notion. For everything else mentioned, I'm currently using the alternatives mentioned above.","title":"Notion"},{"location":"dev-guide/glossary/#playwright","text":"Official site What is it? A Node library to automate Chromium, Firefox and WebKit with a single API. Playwright is built to enable cross-browser web automation that is ever-green, capable, reliable and fast. What do we use it for? This will most likely be our browser automation framework for end-to-end tests. Alternatives: Cypress, Puppeteer, and Selenium would be the main competitors. Playwright is the only one that automates all three major browser engines while running completely inside Node. It's created by Microsoft which gives me faith in its quality. It is, however, very new, having just gotten to its 1.0 release as of May 2020.","title":"Playwright"},{"location":"dev-guide/glossary/#postgresql","text":"Official site What is it? An advanced open-source relational database. What do we use it for? For local development we use Postgres inside a Docker container, and in production we use a Postgres-compatible Aurora instance. In both cases, this serves as the backend for our API, managing users, items, reviews, and everything else we need to store. Alternatives: The main alternatives would be MongoDB and MySQL, which I don't see offering any advantage over Postgres.","title":"PostgreSQL"},{"location":"dev-guide/glossary/#prettier","text":"Official site What is it? An opinionated code formatter What do we use it for? Enforcing code formatting standards across all repos, including tabs over spaces . Alternatives: Prettier seems to be the current standard.","title":"Prettier"},{"location":"dev-guide/glossary/#react","text":"Official site What is it? A web framework for building user interfaces using JavaScript and JSX. What do we use it for? The Patrician site is built using React with Next.js. Alternatives: Angular and Vue are the other major JavaScript frameworks, both of which I've also had some experience using. All three of them use a component architecture and have the same basic capabilities, and we could reasonably use any framework for Patrician. We're currently choosing React because it's popular in the dev community, has lots of open-source components available and widespread support, and has a fairly intuitive coding style with JSX.","title":"React"},{"location":"dev-guide/glossary/#redis","text":"Official site What is it? An open source, in-memory data structure store, used as a database, cache and message broker. Uses a key-value storage method. What do we use it for? We may use this for caching album art to speed up collage generation. Current collage generators take a while because make tons of REST calls, and I think there's a great opportunity for speed improvement here. Alternatives: Memcached?","title":"Redis"},{"location":"dev-guide/glossary/#release-drafter","text":"Official site What is it? A GitHub Actions script that drafts release descriptions based on the PRs that have been merged since last release. What do we use it for? Creating releases for both our UI and API. Alternatives: Zeit/release was initally the option I wanted to use, but that generates release descriptions based on commits, not PRs, meaning we would have to do squash merges. This would be fine if not for the fact that after a squash merge, you can no longer commit to that feature branch, so this could make for a frustrating dev workflow. I'm not opposed to revisiting this idea in the future.","title":"Release-Drafter"},{"location":"dev-guide/glossary/#storybook","text":"Official site What is it? A tool for prototyping UI components in isolation. Compatible with React and other major web frameworks. What do we use it for? We will probably want to use this to test our UI components as we're working on them. Alternatives: ???","title":"Storybook"},{"location":"dev-guide/glossary/#typegraphql","text":"Official site What is it? A Node.js library for generating a GraphQL schema using TypeScript decorators, which can then be fed into a GraphQL server such as Apollo Server. What do we use it for? Creating the GraphqQL schema for Patrician API (part of Warthog). Alternatives: graphql-js, or just using Apollo server on its own and defining the schema using their own syntax or in .graphql files. Using TypeGraphQL, especially as part of Warthog, reduces our boilerplate by having our code, schema, and data models all in one place.","title":"TypeGraphQL"},{"location":"dev-guide/glossary/#typeorm","text":"Official site What is it? An ORM (object-relational model) database client that uses TypeScript decorators to describe data models. What do we use it for? Creating the data models and migrations for Patrician API (part of Warthog). Alternatives: Sequelize used to be the go-to, but TypeORM has since grown in popularity. MikroORM is a similar project that is also gaining traction due to the slow development of TypeORM. Prisma2 looks very promising with its superb TypeScript support and autogenerated classes based on the data model, but it would require defining the data model in its own syntax as opposed to writing out the TypeScript classes. It's something worth revisiting once a stable version is released, but until TypeORM gives us any major issues we will probably stick with it.","title":"TypeORM"},{"location":"dev-guide/glossary/#typescript","text":"Official site What is it? A programming language that transpiles to JavaScript, offering type-checking and deep code editor integration, especially with VSCode. What do we use it for? TypeScript is what the majority (currently all) of our code is written in, including the UI and API. Alternatives: No real alternatives, although due to our microserviec architecture and desire for maximum performance, I could see some of our code moving away from JavaScript altogether, but it'll be a while before that happens.","title":"TypeScript"},{"location":"dev-guide/glossary/#vercel","text":"Official site What is it? A full-stack web hosting platform made by the creators of Next.js with built-in CI/CD (automatically deploys when code is merged in GitHub). What do we use it for? Serving the Patrician UI. Alternatives: Netlify would be an option if we abandoned SSR (making our site fully client-rendered/static). The other options would be AWS (many options to choose from) and Heroku. Vercel has been working great so far, is built by the creators of Next.js, and offers just about everything we need out of the box.","title":"Vercel"},{"location":"dev-guide/glossary/#warthog","text":"Official site What is it? A GraphQL API framework for NodeJS that allows you to define your data model and API schema in one place and autogenerates CRUD operations with sorting, filtering, and pagination out of the box. Built on top of TypeORM and TypeGraphQL. What do we use it for? This is the framework we're currently using for the Patrician API. Alternatives: There are many options for a GraphQL framework that we could go with. I've written prototypes for the basic functionality in Nest.js, Hasura, and a TypeORM/TypeGraphQL app from scratch before I found this framework which offers a lot out of the box. Warthog is a small project and we're still evaluating if it will fit our needs in the long run, but we've had success with it so far. If at some point it fails to do so, we may look at Hasura again (or perhaps Postgraphile) or re-build our API from scratch using either TypeORM/TypeGraphQL or experiment with other frameworks (Prisma2, graphql-yoga, etc).","title":"Warthog"},{"location":"dev-guide/glossary/#zenhub","text":"Official site What is it? A project management tool with deep GitHub integration. What do we use it for? Organizing our GitHub issues into a project board with Epics and a roadmap. Alternatives: Codetree, Jira, GitKraken Glo, Notion, ClickUp, Trello, Taiga","title":"ZenHub"},{"location":"user-guide/search-guide-old/","text":"Example queries Searching for a specific album: my bloody valentine loveless artist:'my bloody valentine' loveless artistId:'my-bloody-valentine-ir1' loveless id:'my-bloody-valentine-loveless' Browsing: artist:'mastodon' released-before:2009 genre:'sludge metal' list:'nostalgic-albums' tag:heavy rating-gt:8 has:review added-in:2020 plays-gt:50 Filter by rating: has:rating rating:8 rating-gt:8 rating-lt:8 Comparing collections: in:user/afantano in:user/afantano/loved-list # This is a view within a user's collection Seeing your play stats (note: you can sort by plays using the \"Sort\" dropdown menu): plays-gt:400 plays-after:2020-01-01 plays-before:2021-01-01 # Only count plays in 2020 plays-in:2020 # Same as above Combining queries: (plays-gt:400) or (tag:favorites) # > 400 plays or has tag \"favorites\" plays-gt:400 tag:favorites filter-type:or # > 400 plays or has tag \"favorites\" plays-gt:400 not:tag:favorites # > 400 and does not have tag \"favorites\" plays-gt:400 not:(tag:favorites) # > 400 and does not have tag \"favorites\" plays-gt:400 not:(tag:favorites or rating-gt:8) # > 400 and does not have tag \"favorites\" or a rating >= 8 Query Syntax Reference Overview Patrician's query syntax is a subset of the Lucene syntax, which is used in MusicBrainz and many other search engines. (It is Lucene-compatible wherever possible, but does not contain the full feature set). This means that a query can be broken into several parts: Term: The smallest unit inside a query (generally a single word). Phrase: A group of words surrounded by quotation marks, treated as a term. Operator: Special character/word that modifies how terms are handled. See Operators below. Field: An additional search category to query, denoted by a colon ( : ). E.g. tag , genre . See Filters below for a full list. Lucene Comparison List of Lucene features Feature Wildcard searches :x: Regular Expression Searches :x: Fuzzy Searches :x: Proximity Searches :x: Range Searches :question: Boosting a Term :x: Boolean Operators: OR :white_check_mark: Boolean Operators: AND :white_check_mark: Boolean Operators: + :white_check_mark: Boolean Operators: NOT :white_check_mark: Boolean Operators: - :white_check_mark: Grouping :white_check_mark: Field Grouping :white_check_mark: Escaping Special Characters :white_check_mark: Operators OR, || quotes \"-\" \"+\" tag:(tag1 tag2) Item Identifiers (These are filters that can only return one or zero items, so all other filters will be ignored) id: mbid: rymId: spotifyId: Filters [date-qualifier] = before/after/in: (YYY0s, YYYY, YYYY-MM, YYYY-MM-DD), on: (YYYY-MM-DD) \"gt\" and \"lt\" will probably equate to \"greater/less than or equal to\" instead of \"greater/less than\", because this is probably the more common use case added-[date-qualifier]: artist: artistId: first-listened-[date-qualifier]: folder: genre: has:artist-review has:favorite-tracks has:likes-dislikes has:rating has:review in:wishlist last-listened-[date-qualifier]: list: plays-gt: plays-lt: rating: rating-gt: rating-lt: released-[date-qualifier]: tag: updated-[date-qualifier]: Not Implemented Yet ([query]) or ([query]) [custom-field]: Any custom field that the user has created, along with any valid value. filter-type:or: Combines every filter using \"OR\" instead of \"AND\" get:artists/items/tracks Which type of result should be returned (default: items) in: (user/[user] or user/[user]/[view]) Whether the item also exists in another user's collection not:[filter] not:([query]) plays-[before/after]: This can be used to create a date range for plays, similar to Last.fm's functionality. (This will not be possible until we are storing play/scrobble data which is way in the future) view:[view] Whether the item exists in a view (which is basically a saved filter query) Other cool ideas: # alias for tag: older_than:2d , newer_than:2d Other search syntaxes to borrow from: Gmail Google GitHub MusicBrainz Lucene","title":"Search guide old"},{"location":"user-guide/search-guide-old/#example-queries","text":"Searching for a specific album: my bloody valentine loveless artist:'my bloody valentine' loveless artistId:'my-bloody-valentine-ir1' loveless id:'my-bloody-valentine-loveless' Browsing: artist:'mastodon' released-before:2009 genre:'sludge metal' list:'nostalgic-albums' tag:heavy rating-gt:8 has:review added-in:2020 plays-gt:50 Filter by rating: has:rating rating:8 rating-gt:8 rating-lt:8 Comparing collections: in:user/afantano in:user/afantano/loved-list # This is a view within a user's collection Seeing your play stats (note: you can sort by plays using the \"Sort\" dropdown menu): plays-gt:400 plays-after:2020-01-01 plays-before:2021-01-01 # Only count plays in 2020 plays-in:2020 # Same as above Combining queries: (plays-gt:400) or (tag:favorites) # > 400 plays or has tag \"favorites\" plays-gt:400 tag:favorites filter-type:or # > 400 plays or has tag \"favorites\" plays-gt:400 not:tag:favorites # > 400 and does not have tag \"favorites\" plays-gt:400 not:(tag:favorites) # > 400 and does not have tag \"favorites\" plays-gt:400 not:(tag:favorites or rating-gt:8) # > 400 and does not have tag \"favorites\" or a rating >= 8","title":"Example queries"},{"location":"user-guide/search-guide-old/#query-syntax-reference","text":"","title":"Query Syntax Reference"},{"location":"user-guide/search-guide-old/#overview","text":"Patrician's query syntax is a subset of the Lucene syntax, which is used in MusicBrainz and many other search engines. (It is Lucene-compatible wherever possible, but does not contain the full feature set). This means that a query can be broken into several parts: Term: The smallest unit inside a query (generally a single word). Phrase: A group of words surrounded by quotation marks, treated as a term. Operator: Special character/word that modifies how terms are handled. See Operators below. Field: An additional search category to query, denoted by a colon ( : ). E.g. tag , genre . See Filters below for a full list.","title":"Overview"},{"location":"user-guide/search-guide-old/#lucene-comparison","text":"List of Lucene features Feature Wildcard searches :x: Regular Expression Searches :x: Fuzzy Searches :x: Proximity Searches :x: Range Searches :question: Boosting a Term :x: Boolean Operators: OR :white_check_mark: Boolean Operators: AND :white_check_mark: Boolean Operators: + :white_check_mark: Boolean Operators: NOT :white_check_mark: Boolean Operators: - :white_check_mark: Grouping :white_check_mark: Field Grouping :white_check_mark: Escaping Special Characters :white_check_mark:","title":"Lucene Comparison"},{"location":"user-guide/search-guide-old/#operators","text":"OR, || quotes \"-\" \"+\" tag:(tag1 tag2)","title":"Operators"},{"location":"user-guide/search-guide-old/#item-identifiers","text":"(These are filters that can only return one or zero items, so all other filters will be ignored) id: mbid: rymId: spotifyId:","title":"Item Identifiers"},{"location":"user-guide/search-guide-old/#filters","text":"[date-qualifier] = before/after/in: (YYY0s, YYYY, YYYY-MM, YYYY-MM-DD), on: (YYYY-MM-DD) \"gt\" and \"lt\" will probably equate to \"greater/less than or equal to\" instead of \"greater/less than\", because this is probably the more common use case added-[date-qualifier]: artist: artistId: first-listened-[date-qualifier]: folder: genre: has:artist-review has:favorite-tracks has:likes-dislikes has:rating has:review in:wishlist last-listened-[date-qualifier]: list: plays-gt: plays-lt: rating: rating-gt: rating-lt: released-[date-qualifier]: tag: updated-[date-qualifier]:","title":"Filters"},{"location":"user-guide/search-guide-old/#not-implemented-yet","text":"([query]) or ([query]) [custom-field]: Any custom field that the user has created, along with any valid value. filter-type:or: Combines every filter using \"OR\" instead of \"AND\" get:artists/items/tracks Which type of result should be returned (default: items) in: (user/[user] or user/[user]/[view]) Whether the item also exists in another user's collection not:[filter] not:([query]) plays-[before/after]: This can be used to create a date range for plays, similar to Last.fm's functionality. (This will not be possible until we are storing play/scrobble data which is way in the future) view:[view] Whether the item exists in a view (which is basically a saved filter query) Other cool ideas: # alias for tag: older_than:2d , newer_than:2d Other search syntaxes to borrow from: Gmail Google GitHub MusicBrainz Lucene","title":"Not Implemented Yet"},{"location":"user-guide/search-guide/","text":"Guide Patrician's search engine is based on the Lucene query syntax, though is not feature-complete with it. For a comparison between the two, see below. Basics What to search How to search it Search for an album master of reality Search by artist artist:\"black sabbath\" Search by artist ID artistId:black-sabbath-uk1 Use multiple fields artistId:black-sabbath-uk1 released:1971 Search by ID id:black-sabbath-master-of-reality-1 mbid:e51e9779-2edc-3b39-959c-299fdb5ed940 spotifyId:7pGb2cOGVz6vLyaZaKOQ7D rymId:2277 By collection data What to search How to search it Search by tag tag:kickass-riffs Items in a list list:nostalgic-albums Items in a folder folder:vinyl Items in a view (views are saved queries) view:current-favs Has a certain rating rating:8 rating-gt:8 rating-lt:8 Has rating has:rating Has review has:review Review has certain terms review-contains:\"awesome\" Artist review exists has:artist-review Has favorite tracks has:favorite-tracks Has likes and dislikes has:likes-dislikes Added to collection during a certain time period added-before:01/05/2019 added-after:2017/12/20 In wishlist in:wishlist Also in another user's collection in:user/afantano Also in another user's collection view in:user/afantano/loved-list By item metadata What to search How to search it Genre genre:industrial-black-metal Release date older: newer: before: after: released-before: released-after: Examples: older:2005 older:2005/05/17 older:05/17/2005 newer:2010s newer:2015/08/02 newer:08/02/2015 Listening history These require that the user has set up Last.fm or ListenBrainz integration to log their listening history. You can also sort by plays using the \"Sort\" dropdown menu, or the sort field if you're using the GraphQL API. What to search How to search it Certain amount of total plays plays-gt:300 plays-lt:150 Certain amount of total plays within a certain year plays-gt:300 plays-in:2020 Certain amount of total plays before a certain year plays-gt:300 plays-before:2020 Certain amount of total plays within a date range plays-gt:300 plays-after:2019/05/18 plays-before:2019/08/27 Last listened within a date range last-listened-after:2019/08/27 last-listened-after:2019 last-listened-after:2010s last-listened-before:2019/08/27 last-listened-before:2019 last-listened-before:2010s last-listened-on:2019/08/27 last-listened-in:2019 last-listened-in:2010s First listened within a date range first-listened-after:2019/08/27 first-listened-after:2019 first-listened-after:2010s first-listened-before:2019/08/27 first-listened-before:2019 first-listened-before:2010s first-listened-on:2019/08/27 first-listened-in:2019 first-listened-in:2010s Operators/Symbols Operator Examples OR plays-gt:400 OR tag:favorites (plays-gt:400) OR (tag:favorites) NOT (-) plays-gt:400 NOT tag:favorites plays-gt:400 -tag:favorites + (Required. Note: Only for terms, not fields) +dark +side +of +moon (this is NOT valid or necessary) +artistId:pink-floyd-uk1 (Grouping) (plays-gt:400 OR rating-gt:8) AND tag:favorites \"Quotes\" artist:\"the dillinger escape plan\" Reference Lucene Comparison List of Lucene features Feature Wildcard searches :x: Regular Expression Searches :x: Fuzzy Searches :x: Proximity Searches :x: Range Searches :question: Boosting a Term :x: Boolean Operators: OR :white_check_mark: Boolean Operators: AND :white_check_mark: Boolean Operators: + :white_check_mark: Boolean Operators: NOT :white_check_mark: Boolean Operators: - :white_check_mark: Grouping :white_check_mark: Field Grouping :white_check_mark: Escaping Special Characters :white_check_mark:","title":"Search Guide"},{"location":"user-guide/search-guide/#guide","text":"Patrician's search engine is based on the Lucene query syntax, though is not feature-complete with it. For a comparison between the two, see below.","title":"Guide"},{"location":"user-guide/search-guide/#basics","text":"What to search How to search it Search for an album master of reality Search by artist artist:\"black sabbath\" Search by artist ID artistId:black-sabbath-uk1 Use multiple fields artistId:black-sabbath-uk1 released:1971 Search by ID id:black-sabbath-master-of-reality-1 mbid:e51e9779-2edc-3b39-959c-299fdb5ed940 spotifyId:7pGb2cOGVz6vLyaZaKOQ7D rymId:2277","title":"Basics"},{"location":"user-guide/search-guide/#by-collection-data","text":"What to search How to search it Search by tag tag:kickass-riffs Items in a list list:nostalgic-albums Items in a folder folder:vinyl Items in a view (views are saved queries) view:current-favs Has a certain rating rating:8 rating-gt:8 rating-lt:8 Has rating has:rating Has review has:review Review has certain terms review-contains:\"awesome\" Artist review exists has:artist-review Has favorite tracks has:favorite-tracks Has likes and dislikes has:likes-dislikes Added to collection during a certain time period added-before:01/05/2019 added-after:2017/12/20 In wishlist in:wishlist Also in another user's collection in:user/afantano Also in another user's collection view in:user/afantano/loved-list","title":"By collection data"},{"location":"user-guide/search-guide/#by-item-metadata","text":"What to search How to search it Genre genre:industrial-black-metal Release date older: newer: before: after: released-before: released-after: Examples: older:2005 older:2005/05/17 older:05/17/2005 newer:2010s newer:2015/08/02 newer:08/02/2015","title":"By item metadata"},{"location":"user-guide/search-guide/#listening-history","text":"These require that the user has set up Last.fm or ListenBrainz integration to log their listening history. You can also sort by plays using the \"Sort\" dropdown menu, or the sort field if you're using the GraphQL API. What to search How to search it Certain amount of total plays plays-gt:300 plays-lt:150 Certain amount of total plays within a certain year plays-gt:300 plays-in:2020 Certain amount of total plays before a certain year plays-gt:300 plays-before:2020 Certain amount of total plays within a date range plays-gt:300 plays-after:2019/05/18 plays-before:2019/08/27 Last listened within a date range last-listened-after:2019/08/27 last-listened-after:2019 last-listened-after:2010s last-listened-before:2019/08/27 last-listened-before:2019 last-listened-before:2010s last-listened-on:2019/08/27 last-listened-in:2019 last-listened-in:2010s First listened within a date range first-listened-after:2019/08/27 first-listened-after:2019 first-listened-after:2010s first-listened-before:2019/08/27 first-listened-before:2019 first-listened-before:2010s first-listened-on:2019/08/27 first-listened-in:2019 first-listened-in:2010s","title":"Listening history"},{"location":"user-guide/search-guide/#operatorssymbols","text":"Operator Examples OR plays-gt:400 OR tag:favorites (plays-gt:400) OR (tag:favorites) NOT (-) plays-gt:400 NOT tag:favorites plays-gt:400 -tag:favorites + (Required. Note: Only for terms, not fields) +dark +side +of +moon (this is NOT valid or necessary) +artistId:pink-floyd-uk1 (Grouping) (plays-gt:400 OR rating-gt:8) AND tag:favorites \"Quotes\" artist:\"the dillinger escape plan\"","title":"Operators/Symbols"},{"location":"user-guide/search-guide/#reference","text":"","title":"Reference"},{"location":"user-guide/search-guide/#lucene-comparison","text":"List of Lucene features Feature Wildcard searches :x: Regular Expression Searches :x: Fuzzy Searches :x: Proximity Searches :x: Range Searches :question: Boosting a Term :x: Boolean Operators: OR :white_check_mark: Boolean Operators: AND :white_check_mark: Boolean Operators: + :white_check_mark: Boolean Operators: NOT :white_check_mark: Boolean Operators: - :white_check_mark: Grouping :white_check_mark: Field Grouping :white_check_mark: Escaping Special Characters :white_check_mark:","title":"Lucene Comparison"},{"location":"user-guide/importing/basics/","text":"","title":"Basics"}]}